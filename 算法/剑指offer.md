# 剑指 offer 思路总结

本部分主要是笔者在练习剑指 offer 时所做的笔记，如果出现错误，希望大家指出！

## 题目

1. 二维数组中的查找
   ```
   题目：

   在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，
   输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。


   思路：

   （1）第一种方式是使用两层循环依次遍历，判断是否含有该整数。这一种方式最坏情况下的时间复杂度为 O(n^2)。

   （2）第二种方式是利用递增序列的特点，我们可以从二维数组的右上角开始遍历。如果当前数值比所求的数要小，则将
       位置向下移动，再进行判断。如果当前数值比所求的数要大，则将位置向左移动，再进行判断。这一种方式最坏情
       况下的时间复杂度为 O(n)。
   ```

2. 替换空格
   ```
   题目：

   请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串
   为 We%20Are%20Happy


   思路：

   使用正则表达式，结合字符串的 replace 方法将空格替换为 “%20”

   str.replace(/\s/g,"%20")
   ```

3. 从头到尾打印链表
   ```
   题目：

   输入一个链表，从尾到头打印链表每个节点的值。


   思路：

   利用栈来实现，首先根据头结点以此遍历链表节点，将节点加入到栈中。当遍历完成后，再将栈中元素弹出并打印，以此
   来实现。栈的实现可以利用 Array 的 push 和 pop 方法来模拟。
   ```

4. 重建二叉树
   ```
   题目：

   输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的
   数字。例如输入前序遍历序列 {1,2,4,7,3,5,6,8} 和中序遍历序列 {4,7,2,1,5,3,8,6}，则重建二叉树并返回。


   思路：

   利用递归的思想来求解，首先先序序列中的第一个元素一定是根元素。然后我们去中序遍历中寻找到该元素的位置，找到
   后该元素的左边部分就是根节点的左子树，右边部分就是根节点的右子树。因此我们可以分别截取对应的部分进行子树的
   递归构建。使用这种方式的时间复杂度为 O(n)，空间复杂度为 O(logn)。
   ```

5. 用两个栈实现队列
   ```
   题目：

   用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。


   思路：

   队列的一个基本特点是，元素先进先出。通过两个栈来模拟时，首先我们将两个栈分为栈1和栈2。当执行队列的 push 
   操作时，直接将元素 push 进栈1中。当队列执行 pop 操作时，首先判断栈2是否为空，如果不为空则直接 pop 元素。
   如果栈2为空，则将栈1中的所有元素 pop 然后 push 到栈2中，然后再执行栈2的 pop 操作。

   扩展：

   当使用两个长度不同的栈来模拟队列时，队列的最大长度为较短栈的长度的两倍。
   ```

6. 旋转数组的最小数字
   ```
   题目：

   把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出
   旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有
   元素都大于0，若数组大小为0，请返回0。


   思路：

   我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值
   相邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。
   ```

7. 斐波那契数列
   ```
   题目：

   大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。 n<=39


   思路：

   斐波那契数列的规律是，第一项为0，第二项为1，第三项以后的值都等于前面两项的和，因此我们可以通过循环的方式，
   不断通过叠加来实现第 n 项值的构建。通过循环而不是递归的方式来实现，时间复杂度降为了 O(n)，空间复杂度为 O(1)。
   ```

8. 跳台阶
   ```
   题目：

   一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

   思路：

   跳台阶的问题是一个动态规划的问题，由于以此只能够1级或者2级，因此跳上 n 级台阶一共有两种方案，一种是从 n-1 
   跳上，一种是从 n-2 级跳上，因此 f(n) = f(n-1) + f(n-2)。

   和斐波那契数列类似，不过初始两项的值变为了 1 和 2，后面每项的值等于前面两项的和。
   ```

9. 变态跳台阶
   ```
   题目：

   一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳
   法。

   思路：

   变态跳台阶的问题同上一个问题的思考方案是一样的，我们可以得到一个结论是，每一项的值都等于前面所有向的值的和。
   
   f(1) = 1
   f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。
   f(3) = f(3-1) + f(3-2) + f(3-3) 
   ...
   f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n) 
   
   再次总结可得

                 | 1       ,(n=0 ) 
   f(n) =        | 1       ,(n=1 )
                 | 2*f(n-1),(n>=2)
   ```

10. 矩形覆盖
    ```
    题目：

    我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大
    矩形，总共有多少种方法？


    思路：

    依旧是斐波那契数列的应用
    ```

11. 二进制中1的个数
    ```
    题目：

    输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。


    思路：

    一个不为 0 的整数的二进制表示，一定会有一位为1。我们找到最右边的一位1，当我们将整数减去1时，最右边的一位1变
    为0，它后面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位1。因此判断一个二进制中1
    的个数，我们可以判断这个数可以经历多少次这样的过程。

    如：1100&1011=1000 
    ```

12. 数值的整数次方
    ```
    题目：

    给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。


    思路：

    首先我们需要判断 exponent 正负和零取值三种情况，根据不同的情况通过递归来实现。 
    ```

13. 调整数组顺序使奇数位于偶数前面
    ```
    题目：

    输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位
    于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。


    思路：

    由于需要考虑到调整之后的稳定性，因此我们可以使用辅助数组的方式。首先对数组中的元素进行遍历，每遇到一个奇数
    就将它加入到奇数辅助数组中，每遇到一个偶数，就将它将入到偶数辅助数组中。最后再将两个数组合并。这一种方法的
    时间复杂度为 O(n)，空间复杂度为 O(n)。
    ```

14. 链表中倒数第 k 个节点
    ```
    题目：

    输入一个链表，输出该链表中倒数第k个结点。


    思路：

    使用两个指针，先让第一个和第二个指针都指向头结点，然后再让第二个指针走 k-1 步，到达第 k 个节点。然后两个
    指针同时向后移动，当第二个指针到达末尾时，第一个指针指向的就是倒数第 k 个节点了。
    ```

15. 反转链表
    ```
    题目：

    输入一个链表，反转链表后，输出链表的所有元素。


    思路：

    通过设置三个变量 pre、current 和 next，分别用来保存前继节点、当前节点和后继结点。从第一个节点开始向后遍
    历，首先将当前节点的后继节点保存到 next 中，然后将当前节点的后继节点设置为 pre，然后再将 pre 设置为当前节
    点，current 设置为 next 节点，实现下一次循环。
    ```

16. 合并两个排序的链表
    ```
    题目：

    输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

    思路：

    通过递归的方式，依次将两个链表的元素递归进行对比。
    ```